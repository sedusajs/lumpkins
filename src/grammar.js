// Generated automatically by nearley
// http://github.com/Hardmath123/nearley
(function () {
  function id (x) { return x[0] }

  const lexer = require('./lexer')
  const emitter = require('./emitter')
  // const tpl = emitter.createTemplate();
  const {Interpolation} = emitter

  function handleUnary (operator, operand) {
    switch (operator) {
      case '-': return emitter.emitUnaryMinus(operand)
      case '+': return emitter.emitUnaryPlus(operand)
      case '!': return emitter.emitNegation(operand)
      case 'typeof': return emitter.emitGetType(operand)
    }
  }
  const grammar = {
    Lexer: lexer,
    ParserRules: [
      {'name': 'tempate', 'symbols': ['interpolation', (lexer.has('eof') ? {type: 'eof'} : eof)], 'postprocess': ([d]) => d.join()},
      {'name': 'interpolation', 'symbols': [], 'postprocess': d => new Interpolation()},
      {'name': 'interpolation', 'symbols': ['interpolation', 'interpolation_item'], 'postprocess': ([interpolation, item]) => interpolation.add(item)},
      {'name': 'interpolation_item', 'symbols': ['interpolation_text'], 'postprocess': ([d]) => Interpolation.text(d)},
      {'name': 'interpolation_item', 'symbols': ['interpolation_tag'], 'postprocess': ([d]) => Interpolation.tag(d)},
      {'name': 'interpolation_item', 'symbols': ['interpolation_expression'], 'postprocess': ([d]) => Interpolation.expression(d)},
      {'name': 'interpolation_text', 'symbols': [(lexer.has('text') ? {type: 'text'} : text)], 'postprocess': d => d[0].value},
      {'name': 'interpolation_text', 'symbols': [(lexer.has('escaped_backslash') ? {type: 'escaped_backslash'} : escaped_backslash)], 'postprocess': d => '\\'},
      {'name': 'interpolation_text', 'symbols': [(lexer.has('escaped_lt') ? {type: 'escaped_lt'} : escaped_lt)], 'postprocess': d => '<'},
      {'name': 'interpolation_text', 'symbols': [(lexer.has('escaped_expression_start') ? {type: 'escaped_expression_start'} : escaped_expression_start)], 'postprocess': d => '{'},
      {'name': 'interpolation_text', 'symbols': [(lexer.has('escaped_pipe') ? {type: 'escaped_pipe'} : escaped_pipe)], 'postprocess': d => '|'},
      {'name': 'interpolation_tag', 'symbols': [(lexer.has('tag') ? {type: 'tag'} : tag)], 'postprocess': ([d]) => emitter.emitTag(d.value, d)},
      {'name': 'interpolation_expression', 'symbols': [{'literal': '{'}, '_', 'rh_expression', '_', {'literal': '}'}], 'postprocess': d => d[2]},
      {'name': 'interpolation_expression', 'symbols': [{'literal': '{'}, '_', {'literal': '}'}], 'postprocess': () => `""`},
      {'name': 'rh_expression', 'symbols': ['rh_coalescing'], 'postprocess': ([d]) => emitter.emitExpression(d)},
      {'name': 'lh_expression', 'symbols': ['lh_coalescing'], 'postprocess': ([d]) => emitter.emitExpression(d)},
      {'name': 'rh_coalescing', 'symbols': ['lh_logical_or', '_', 'coalescing_op', '_', 'rh_coalescing'], 'postprocess': d => d[0] ? d[0] : d[4]},
      {'name': 'rh_coalescing', 'symbols': ['rh_logical_or'], 'postprocess': id},
      {'name': 'lh_coalescing', 'symbols': ['lh_logical_or', '_', 'coalescing_op', '_', 'lh_coalescing'], 'postprocess': d => d[0] ? d[0] : d[4]},
      {'name': 'lh_coalescing', 'symbols': ['lh_logical_or'], 'postprocess': id},
      {'name': 'coalescing_op', 'symbols': [{'literal': '??'}]},
      {'name': 'coalescing_op', 'symbols': [{'literal': '???'}]},
      {'name': 'rh_logical_or', 'symbols': ['lh_logical_or', '__', {'literal': 'or'}, '__', 'rh_logical_and'], 'postprocess': d => d[0] || d[4]},
      {'name': 'rh_logical_or', 'symbols': ['rh_logical_and'], 'postprocess': id},
      {'name': 'lh_logical_or', 'symbols': ['lh_logical_or', '__', {'literal': 'or'}, '__', 'lh_logical_and'], 'postprocess': d => d[0] || d[4]},
      {'name': 'lh_logical_or', 'symbols': ['lh_logical_and'], 'postprocess': id},
      {'name': 'rh_logical_and', 'symbols': ['lh_logical_and', '__', {'literal': 'and'}, '__', 'rh_equality'], 'postprocess': d => d[0] && d[4]},
      {'name': 'rh_logical_and', 'symbols': ['rh_equality'], 'postprocess': id},
      {'name': 'lh_logical_and', 'symbols': ['lh_logical_and', '__', {'literal': 'and'}, '__', 'lh_equality'], 'postprocess': d => d[0] && d[4]},
      {'name': 'lh_logical_and', 'symbols': ['lh_equality'], 'postprocess': id},
      {'name': 'rh_equality', 'symbols': ['lh_equality', '_', 'equality_op', '_', 'rh_relational'], 'postprocess': d => d[0] == d[4]},
      {'name': 'rh_equality', 'symbols': ['rh_relational'], 'postprocess': id},
      {'name': 'lh_equality', 'symbols': ['lh_equality', '_', 'equality_op', '_', 'lh_relational'], 'postprocess': d => d[0] == d[4]},
      {'name': 'lh_equality', 'symbols': ['lh_relational'], 'postprocess': id},
      {'name': 'equality_op', 'symbols': [{'literal': '=='}]},
      {'name': 'equality_op', 'symbols': [{'literal': '==='}]},
      {'name': 'equality_op', 'symbols': [{'literal': '!='}]},
      {'name': 'equality_op', 'symbols': [{'literal': '!=='}]},
      {'name': 'rh_relational', 'symbols': ['lh_relational', '_', 'relational_op', '_', 'rh_additive'], 'postprocess': (d) => d[0] < d[4]},
      {'name': 'rh_relational', 'symbols': ['rh_additive'], 'postprocess': id},
      {'name': 'lh_relational', 'symbols': ['lh_relational', '_', 'relational_op', '_', 'lh_additive'], 'postprocess': (d) => d[0] < d[4]},
      {'name': 'lh_relational', 'symbols': ['lh_additive'], 'postprocess': id},
      {'name': 'relational_op', 'symbols': [{'literal': '<'}]},
      {'name': 'relational_op', 'symbols': [{'literal': '<='}]},
      {'name': 'relational_op', 'symbols': [{'literal': '>'}]},
      {'name': 'relational_op', 'symbols': [{'literal': '>='}]},
      {'name': 'relational_op', 'symbols': [{'literal': 'in'}]},
      {'name': 'rh_additive', 'symbols': ['lh_additive', '_', 'additive_op', '_', 'rh_multiplicative'], 'postprocess': (d) => d[0] + d[4]},
      {'name': 'rh_additive', 'symbols': ['rh_multiplicative'], 'postprocess': id},
      {'name': 'lh_additive', 'symbols': ['lh_additive', '_', 'additive_op', '_', 'lh_multiplicative'], 'postprocess': (d) => d[0] + d[4]},
      {'name': 'lh_additive', 'symbols': ['lh_multiplicative'], 'postprocess': id},
      {'name': 'additive_op', 'symbols': [{'literal': '+'}]},
      {'name': 'additive_op', 'symbols': [{'literal': '-'}]},
      {'name': 'rh_multiplicative', 'symbols': ['lh_multiplicative', '_', 'multiplicative_op', '_', 'rh_exponentative'], 'postprocess': (d) => `(${d[0]}) * ${d[4]}`},
      {'name': 'rh_multiplicative', 'symbols': ['rh_exponentative'], 'postprocess': id},
      {'name': 'lh_multiplicative', 'symbols': ['lh_multiplicative', '_', 'multiplicative_op', '_', 'lh_exponentative'], 'postprocess': (d) => `(${d[0]}) * ${d[4]}`},
      {'name': 'lh_multiplicative', 'symbols': ['lh_exponentative'], 'postprocess': id},
      {'name': 'multiplicative_op', 'symbols': [{'literal': '*'}]},
      {'name': 'multiplicative_op', 'symbols': [{'literal': '/'}]},
      {'name': 'multiplicative_op', 'symbols': [{'literal': '%'}]},
      {'name': 'rh_exponentative', 'symbols': ['lh_exponentative', '_', {'literal': '**'}, '_', 'rh_unary'], 'postprocess': d => emitter.emitExponentative(d[0], d[4])},
      {'name': 'rh_exponentative', 'symbols': ['rh_unary'], 'postprocess': id},
      {'name': 'lh_exponentative', 'symbols': ['lh_exponentative', '_', {'literal': '**'}, '_', 'lh_unary'], 'postprocess': d => emitter.emitExponentative(d[0], d[4])},
      {'name': 'lh_exponentative', 'symbols': ['lh_unary'], 'postprocess': id},
      {'name': 'rh_unary', 'symbols': ['unary_op', '_', 'rh_unary'], 'postprocess': ([[operator], , operand]) => handleUnary(operator.value, operand)},
      {'name': 'rh_unary', 'symbols': ['rh_member'], 'postprocess': id},
      {'name': 'lh_unary', 'symbols': ['unary_op', '_', 'lh_unary'], 'postprocess': ([[operator], , operand]) => handleUnary(operator.value, operand)},
      {'name': 'lh_unary', 'symbols': ['lh_member'], 'postprocess': id},
      {'name': 'unary_op', 'symbols': [{'literal': '-'}]},
      {'name': 'unary_op', 'symbols': [{'literal': '+'}]},
      {'name': 'unary_op', 'symbols': [{'literal': '!'}]},
      {'name': 'unary_op', 'symbols': [{'literal': 'typeof'}]},
      {'name': 'rh_member', 'symbols': ['member'], 'postprocess': id},
      {'name': 'rh_member', 'symbols': ['rh_call'], 'postprocess': id},
      {'name': 'lh_member', 'symbols': ['member'], 'postprocess': id},
      {'name': 'lh_member', 'symbols': ['lh_call'], 'postprocess': id},
      {'name': 'member', 'symbols': ['lh_member', '_', {'literal': '.'}, '_', 'member_spec'], 'postprocess': d => emitter.emitPropertyGet(d[0], d[4], true)},
      {'name': 'member', 'symbols': ['lh_member', '_', {'literal': '?'}, {'literal': '.'}, '_', 'member_spec'], 'postprocess': d => emitter.emitPropertyGet(d[0], d[5], false)},
      {'name': 'member', 'symbols': ['lh_member', '_', {'literal': '['}, '_', 'rh_expression', '_', {'literal': ']'}], 'postprocess': d => emitter.emitPropertyGetDynamic(d[0], d[4], true)},
      {'name': 'member', 'symbols': ['lh_member', '_', {'literal': '?'}, {'literal': '['}, '_', 'rh_expression', '_', {'literal': ']'}], 'postprocess': d => emitter.emitPropertyGetDynamic(d[0], d[5], false)},
      {'name': 'member_spec', 'symbols': [(lexer.has('identifier') ? {type: 'identifier'} : identifier)], 'postprocess': ([d]) => d.value},
      {'name': 'member_spec', 'symbols': ['keyword'], 'postprocess': ([[d]]) => d.value},
      {'name': 'rh_call', 'symbols': ['call']},
      {'name': 'rh_call', 'symbols': ['rh_parens']},
      {'name': 'lh_call', 'symbols': ['call']},
      {'name': 'lh_call', 'symbols': ['lh_parens']},
      {'name': 'call', 'symbols': ['lh_member', '_', 'arguments']},
      {'name': 'call', 'symbols': ['lh_member', '_', {'literal': '?'}, 'arguments']},
      {'name': 'arguments', 'symbols': [{'literal': '('}, '_', {'literal': ')'}]},
      {'name': 'arguments', 'symbols': [{'literal': '('}, '_', 'argument_list', '_', {'literal': ')'}]},
      {'name': 'argument_list', 'symbols': ['argument']},
      {'name': 'argument_list', 'symbols': ['argument_list', '_', {'literal': ','}, '_', 'argument']},
      {'name': 'argument', 'symbols': ['rh_expression']},
      {'name': 'rh_parens', 'symbols': [{'literal': '('}, '_', 'rh_expression', '_', {'literal': ')'}], 'postprocess': d => emitter.emitExpression(d[2])},
      {'name': 'rh_parens', 'symbols': ['flow'], 'postprocess': id},
      {'name': 'rh_parens', 'symbols': ['value'], 'postprocess': id},
      {'name': 'lh_parens', 'symbols': [{'literal': '('}, '_', 'rh_expression', '_', {'literal': ')'}], 'postprocess': d => emitter.emitExpression(d[2])},
      {'name': 'lh_parens', 'symbols': ['value'], 'postprocess': id},
      {'name': 'flow', 'symbols': [{'literal': 'if'}, '__', 'rh_expression', '__', {'literal': 'then'}, '__', 'rh_expression', '__', {'literal': 'else'}, '__', 'rh_expression'], 'postprocess': d => emitter.emitConditional(d[2], d[6], d[10])},
      {'name': 'value', 'symbols': ['literal'], 'postprocess': id},
      {'name': 'value', 'symbols': ['ident'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['number'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['string'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['bool'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['null_literal'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['interpolation_literal'], 'postprocess': id},
      {'name': 'literal', 'symbols': ['void_literal'], 'postprocess': id},
      {'name': 'ident', 'symbols': [(lexer.has('identifier') ? {type: 'identifier'} : identifier)], 'postprocess': ([d]) => emitter.emitGlobalPropertyGet(d.value, d)},
      {'name': 'number', 'symbols': [(lexer.has('decimal_number') ? {type: 'decimal_number'} : decimal_number)], 'postprocess': ([d]) => emitter.emitDecimal(d.value, d)},
      {'name': 'number', 'symbols': [{'literal': 'NaN'}], 'postprocess': () => emitter.emitNaN()},
      {'name': 'number', 'symbols': [{'literal': 'Infinity'}], 'postprocess': () => emitter.emitInfinity()},
      {'name': 'string', 'symbols': [(lexer.has('double_quoted_string') ? {type: 'double_quoted_string'} : double_quoted_string)], 'postprocess': ([s]) => emitter.emitString(s.value)},
      {'name': 'string', 'symbols': [(lexer.has('single_quoted_string') ? {type: 'single_quoted_string'} : single_quoted_string)], 'postprocess': ([s]) => emitter.emitString(s.value)},
      {'name': 'bool', 'symbols': [{'literal': 'true'}], 'postprocess': () => emitter.emitTrue()},
      {'name': 'bool', 'symbols': [{'literal': 'false'}], 'postprocess': () => emitter.emitFalse()},
      {'name': 'null_literal', 'symbols': [{'literal': 'null'}], 'postprocess': () => emitter.emitNull()},
      {'name': 'interpolation_literal', 'symbols': [{'literal': '|'}, 'interpolation', {'literal': '|'}], 'postprocess': ([, d]) => d.join()},
      {'name': 'void_literal', 'symbols': [{'literal': '('}, '_', {'literal': ')'}], 'postprocess': () => emitter.emitVoid()},
      {'name': 'keyword', 'symbols': [{'literal': 'true'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'false'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'null'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'NaN'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'Infinity'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'if'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'then'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'else'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'this'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'typeof'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'in'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'and'}]},
      {'name': 'keyword', 'symbols': [{'literal': 'or'}]},
      {'name': '_', 'symbols': []},
      {'name': '_', 'symbols': [(lexer.has('space') ? {type: 'space'} : space)], 'postprocess': () => undefined},
      {'name': '__', 'symbols': [(lexer.has('space') ? {type: 'space'} : space)], 'postprocess': () => undefined}
    ],
    ParserStart: 'tempate'
  }
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = grammar
  } else {
    window.grammar = grammar
  }
})()
